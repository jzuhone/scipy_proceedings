:author: John A. ZuHone
:email: jzuhone@milkyway.gsfc.nasa.gov
:institution: Astrophysics Science Division, Laboratory for High Energy Astrophysics, Code 662, NASA/Goddard Space Flight Center, Greenbelt, MD 20771

:author: Veronica Biffi
:email: biffi@sissa.it
:institution: SISSA - Scuola Internazionale Superiore di Studi Avanzati, Via Bonomea 265, 34136 Trieste, Italy

:author: Eric Hallman
:email: hallman13@gmail.com
:institution: Center for Astrophysics and Space Astronomy, Department of Astrophysical & Planetary Science, University of Colorado, Boulder, CO 80309

:author: Scott W. Randall
:email: srandall@cfa.harvard.edu
:institution: Harvard-Smithsonian Center for Astrophysics, 60 Garden Street, Cambridge, MA 02138

:author: Adam Foster
:email: afoster@cfa.harvard.edu
:institution: Harvard-Smithsonian Center for Astrophysics, 60 Garden Street, Cambridge, MA 02138

:author: Christian Schmid
:email: christian.schmid@sternwarte.uni-erlangen.de
:institution: Dr. Karl Remeis-Sternwarte & ECAP, Sternwartstr. 7, 96049 Bamberg, Germany

-----------------------------------------
Simulating X-ray Observations with Python
-----------------------------------------

.. class:: abstract

  We present an implementation of such an algorithm in the ``yt`` volumetric analysis 
  software package. We describe the underlying physical model and present a detailed 
  example of the creation of a simulated X-ray observation.
  
.. class:: keywords

  astronomical observations, astrophysics simulations, visualization

Introduction
------------

X-ray astronomy is an important 

Since X-rays are prevented from reaching ground-based instruments by Earth's atmosphere, astronomers must employ space-based telescopes to observe them. 

Model
-----

The overall model that underlies our algorithm may be split up into roughly three parts: a spectral emission model that determines how the photons are generated by the emitting plasma, a spatial model that determines the spatial distribution of the emitted photons and their reception in the observer's frame, and an instrumental model that describes the properties of the instrument which detects the incoming photons. We briefly describe each of these in turn. 

.. figure:: schematic.png
   :align: center
   :figclass: w
   :scale: 25 %
   
   Schematic representation of a roughly spherical X-ray emitting object, such as a 
   galaxy cluster. The volume element at position :math:`{\bf r}` in the unprimed
   coordinate system of the source has a velocity :math:`{\bf v}`. Photons emitted 
   along the direction given by :math:`\hat{\bf n}` will be received in the observer's
   frame in the primed coordinate system, and will be Doppler-shifted by the line-of-sight
   velocity component :math:`v_{z'}`. :math:`{\rm Chandra}` telescope image credit: 
   NASA/CXC. :label:`schematic`

Spectral Emission Model
=======================

In order to generate the simulated photons, a spectral model for the photons must first be specified. In general, the normalization of the photon spectrum for a given volume element will be set by the number density of emitting particles, and the shape of the spectrum will be set by the energetics of the same particles. 

As a specific and highly relevant example, one of the most common sources of X-ray emission is that from a low-density, high-temperature, thermal plasma, such as that found in the solar corona, supernova remnants, "early-type" galaxies, galaxy groups, and galaxy clusters. The specific photon emissivity associated with a given density, temperature, and metallicity of such a plasma is given by 

.. math::
  :label: emissivity

  \epsilon_E^\gamma = n_en_H\Lambda(E,T,Z)~{\rm photons~s^{-1}~cm^{-3}}

where :math:`n_e` and :math:`n_H` are the electron and proton number densities in :math:`{\rm cm^{-3}}` and :math:`\Lambda(E,T,Z)` is the spectral. In this case, the normalization of the spectrum for a volume element is set by the emission measure EM = :math:`\int{n_en_H}dV`, and the shape of the spectrum is determined by the temperature and metallicity. The dominant contributions to :math:`\Lambda` for an optically-thin, fully-ionized plasma are bremmstrahlung ("free-free") emission and collisional line excitation. A number of models for the emissivity of such a plasma have been developed, including Raymond-Smith, MeKaL, and APEC. 

However, astrophysical X-ray emission arises from a variety of physical processes and sources, and in some cases multiple sources may be emitting from within the same volume. For example, cosmic-ray electrons in galaxy clusters produce a power-law spectrum of X-ray emission at high energies via inverse-Compton scattering of the cosmic microwave background. Recently, a possible detection of line emission from annihilating dark matter particles was identified in stacked spectra of galaxy clusters. The flexibility of our approach allows us to implement one or several models for the X-ray emission arising from a variety of physical processes as the situation requires. 

The emitted spectrum is modified by a number of physical processes. The first, occurring at the source itself, is Doppler shifting and broadening of spectral lines, which arises from bulk motion of the gas and turbulence. Second, since many X-ray sources are at cosmological distances, the entire spectrum is cosmologically redshifted. Finally, gas within the Milky Way galaxy situated between the observer and the source absorbs a large number of the photons, particularly at low energies. All of these effects must be taken into account when modeling the observed spectrum. 

Spatial Model
=============

The total emission from any extended object as a function of position on the sky is a projection of the total emission along the line of sight, minus the emission that has been either absorbed or scattered out of the sight-line along the way. For most X-ray emitting sources that we are interested in, the plasma is optically thin to the photons, so they pass essentially unimpeded from the source to the observer (with the caveat that some photons are absorbed by Galactic foreground gas, as mentioned above). Therefore, when constructing our synthetic observations we assume the entire source is optically thin and that the observed emission is a simple integration of the all emitting volume elements along that line of sight. 

For an astrophysical simulation, the relevant volume elements are typically grid cells or Lagrangian particles, the latter of which has a spatial extent defined by a spatial smoothing kernel. These elements provide the model for the spatial distribution of the photons. Figure :ref:`schematic` shows a schematic representation of a roughly spherical source of X-ray photons with an example 

Instrumental Model
==================

Unfortunately, the data products of X-ray observations do not simply consists of the original sky positions and energies of the received photons. Spatially, the positions of the received photons on the detector are affected by a number of instrumental factors. These include vignetting, the layout of the CCD chips, and a typically spatially dependent point-spread function. Similarly, the photon energies are binned up by the detectors into a set of discrete energy channels, and there is typically not a simple one-to-one mapping between which channel a given photon ends up in and its original energy, but is instead represented by a non-diagonal response matrix. Finally, the "effective" collecting area of the telescope is also energy-dependent, and also varies with position on the detector. 

For accurate comparison of our mock observations to real observations, and for compatibility with existing analysis tools, these effects must be taken into account. In our framework, we provide two ways of convolving the detected photons with instrumental responses, depending on the level of sophistication required. The first is a "bare-bones" approach, where the user can specify a point-spread function to convolve the photon positions with, and energy response files to convolve the photon energies with. This will result in photon distributions that are similar enough to the final data products of real observations to be sufficient for most purposes. 

However, some users may require a full simulation of a given telescope or may wish to compare observations of the same simulated system by multiple instruments. Several software packages exist for this purpose, including ``MARX`` (`Chandra`), ``SIMX``, and ``Sixte``. Therefore, we also provide convenient output formats for the synthetic photons in order that they may be easily imported into these packages. 

.. figure:: sloshing.png
   :align: center
   :figclass: w
   :width: 100%
   
   Slices of density (left) and temperature (right) of an ``Athena`` dataset of a 
   galaxy cluster core. :label:`sloshing`

Implementation
--------------

The model described here has been implemented in ``yt`` [Tur11]_, a Python-based visualization and analysis toolkit for volumetric data. ``yt`` has a number of strengths that make it an ideal package for implementing our algorithm.

The first is that ``yt`` has support for analyzing data from a large number of astrophysical simulation codes. These include ``FLASH``, ``Enzo``, ``Gadget``, ``Athena``, etc. The simulation-specific code is contained within various "frontend" implementations, and the user-facing API to perform the analysis on the data is the same regardless of the type of simulation being analyzed. This makes it possible to use the same scripts or IPython notebooks to generate photons for a number of different dataset types. 

The second strength is related, in that by largely abstracting out the simulation-specific concepts of "cells", "grids", "particles", "smoothing lengths", etc., ``yt`` provides a window on to the data defined primarily in terms of physically motivated volumetric region objects. These include spheres, disks, rectangular regions, regions defined on particular cuts on fields, etc. Arbitrary combinations of these region types are also possible. These volumetric region objects serve as natural starting points for generating X-ray photons from not only physically relevant regions within a simulation but also from simple "toy" models which have been constructed from scratch. 

The third major strength is that implementing our model in ``yt`` makes it possible to easily make use of the wide variety of useful libraries available within the scientific Python ecosystem. Our implementation uses SciPy for integration, AstroPy for handling celestial coordinate systems and FITS I/O, and PyXspec for generating X-ray spectra. Tools for analyzing astrophysical X-ray data are also being implemented in Python (e.g., ``CIAO``'s ``Sherpa`` package) so possibilities exist for integration with these tools as well. 

Method
------

Here we present a workable example of creating simulated X-ray events using ``yt``'s photon simulator. This code has been implemented in ``yt`` v. 3.0 and is available as a Python script at :    

Step 1: Generating the Photons in the Source Frame
==================================================

First, we must import the necessary modules: 

.. code-block:: python      

  import yt
  from yt.analysis_modules.photon_simulator.api \
      import *
  from yt.utilities.cosmology import Cosmology

We will use an ``Athena`` dataset of a galaxy cluster core, which can be downloaded from http://yt-project.org/data/MHDSloshing.tar.gz:

.. code-block:: python    

   parameters={"time_unit":(1.0,"Myr"),
               "length_unit":(1.0,"Mpc"),
               "mass_unit":(1.0e14,"Msun")}

   ds = yt.load("MHDSloshing/virgo_low_res.0054.vtk",
                parameters=parameters)
   
Slices through the density and temperature of the simulation dataset are shown in Figure :ref:`sloshing`. The photons will be created from a spherical region centered on the domain center, with a radius of 250 kpc:

.. code-block:: python

  sp = ds.sphere("c", (250., "kpc"))
  
This will serve as our ``data_source`` that we will use later. Next, we
need to create the ``SpectralModel`` instance that will determine how
the data in the grid cells will generate photons. A number of options are available, but we will use the ``XSpecThermalModel``, which allows one to
use any thermal model that is known to `XSPEC <https://heasarc.gsfc.nasa.gov/xanadu/xspec/>`_, such as ``"mekal"`` or ``"apec"``:

.. code-block:: python

  mekal_model = XSpecThermalModel("mekal", 0.01, 
                                  10.0, 2000)

This requires XSPEC and
`PyXspec <http://heasarc.gsfc.nasa.gov/xanadu/xspec/python/html/>`_ to
be installed. 

Now that we have our ``SpectralModel``, we need to connect this model 
to a ``PhotonModel`` that will connect the field data in the 
``data_source`` to the spectral model to actually generate photons. 
For thermal spectra, we have a special ``PhotonModel`` called
``ThermalPhotonModel``:

.. code-block:: python

  thermal_model = ThermalPhotonModel(apec_model, 
                                     X_H=0.75, 
                                     Zmet=0.3)

Where we pass in the ``SpectralModel``, and can optionally set values for
the hydrogen mass fraction ``X_H`` and metallicity ``Z_met``, the latter of which may be a single floating-point value or the name of the ``yt`` field representing the spatially-dependent metallicity.

Next, we need to specify "fiducial" values for the telescope collecting area, exposure time, and cosmological redshift. Since the initial photon generation will act as a source for Monte-Carlo sampling for more realistic values of these parameters later, we choose generous values so that there will be a large number of photons to sample from. We also construct a ``Cosmology`` object, which will be used to determine the source distance from its redshift:

.. code-block:: python

  A = 6000.
  exp_time = 4.0e5
  redshift = 0.05
  cosmo = Cosmology()

Now, we finally combine everything together and create a ``PhotonList``
instance:

.. code-block:: python

  photons = PhotonList.from_scratch(sp, redshift, A, 
                                    exp_time,
                                    thermal_model, 
                                    center="c",
                                    cosmology=cosmo)

where we have used all of the parameters defined above, and ``center`` defines the reference coordinate which will become the origin of the photon coordinates.

At this point, the ``photons`` are distributed in the three-dimensional
space of the ``data_source``, with energies in the rest frame of the
plasma. These ``photons`` can be saved to disk in an HDF5 file:

.. code-block:: python

  photons.write_h5_file("my_photons.h5")

Which is most useful if it takes a long time to generate the photons,
because a ``PhotonList`` can be created in-memory from the dataset
stored on disk:

.. code-block:: python

  photons = PhotonList.from_file("my_photons.h5")

This enables the creation of many simulated event sets, along different
projections, at different redshifts, with different exposure times, and
different instruments, with the same ``data_source``, without having to
repeat the expensive first step of generating the photons.

Step 2: Observing the Photons in the Receiver's Frame
=====================================================

Once a set of photons is generated, they can be projected along a line of sight to create a synthetic observation. At this point, several effects must be taken into account. First, if simulating galactic foreground absorption is desired,  it is necessary to set up a spectral model for the absorption coefficient, similar to the spectral model for the emitted photons set up previously. Here again, there are multiple options, but for the current example we use ``XSpecAbsorbModel``, which allows one to use any absorption model that XSpec is aware of that takes only the column density :math:`N_H` as input.

.. code-block:: python

  N_H = 0.1 
  a_mod = XSpecAbsorbModel("wabs", N_H) 

Now the photons may be projected. First, we choose a line-of-sight vector ``L``. Second, we adjust the exposure time and the redshift to more realistic values. Third, we'll pass in the absorption ``SpectrumModel``. Fourth, we'll specify a ``sky_center`` in RA, Dec on the sky in degrees. In this case, we'll also provide two instrumental responses to convolve the observed photons with.     
     
.. code-block:: python
      
  ARF = "chandra_ACIS-S3_onaxis_arf.fits"
  RMF = "chandra_ACIS-S3_onaxis_rmf.fits"
  resp = [ARF,RMF]
  L = [0.0,0.0,1.0]
  events = photons.project_photons(L, 
                                   exp_time_new=2.0e5, 
                                   redshift_new=0.07, 
                                   absorb_model=a_mod,
                                   responses=resp)
       
``project_photons`` draws events uniformly from the ``photons`` sample, the number of which is set by the (optional) parameters ``redshift_new``, ``exp_time_new``, and ``area_new``. These events have positions on the sky defined by the new coordinate frame corresponding to the normal vector ``L``, and have their energies Doppler-shifted by the corresponding line-of-sight velocity of their originating cell in this same frame. The energies are also cosmologically redshifted. Finally, as a last step, a number of the events are removed according to the supplied Galactic absorption model ``absorb_model`` before arriving in the observer's frame. 

In the case where instrumental ``responses`` are provided, there are two additional steps. If an ARF is provided, the maximum value of the effective area curve will serve as the ``area_new`` parameter, and after the absorption step a number of events are further removed using the effective area curve as the acceptance/rejection criterion. If an RMF is provided, the event energies will convolved with it to produce a new array with their resulting spectral channels. 

Step 3: Output and Further Analysis
===================================

The ``events`` may be binned into an image and written to a FITS file:           
             
.. code-block:: python

  events.write_fits_image("my_image.fits", 
                          clobber=True, 
                          emin=0.5, emax=7.0)
             
where ``emin`` and ``emax`` specify the energy range for the image. 
Instead of the simple convolution with instrument responses provided by ``photon_simulator``, the most accurate simulation of a synthetic observation is facilitated by exporting the unconvolved event positions and energies to a software package that has been designed to simulate a particular instrument. For input to MARX, we provide an implementation of a MARX "user source" at http://bitbucket.org/jzuhone/yt_marx_source, which takes as input an HDF5 file:

.. code-block:: python

  events.write_h5_file("my_events.h5")
  
Input to SIMX and Sixte is handled via SIMPUT files, which can also be outputted:

.. code-block:: python

  events.write_simput_file("my_events", 
                           clobber=True, 
                           emin=0.1, emax=10.0))
  
where ``emin`` and ``emax`` are the energy range in keV of the outputted events. Figure shows several examples of the generated photons passed through various instrument simulations. For this to work correctly, the ``events`` object must be generated by a call to ``project_photons`` which does not apply responses, since these will be applied by the instrument simulator. 

Summary
-------

We have developed an analysis module within the Python-based volumetric data analysis toolkit ``yt`` to construct synthetic X-ray observations of astrophysical sources.

References
----------

.. [Bif12] Biffi, V., Dolag, K., Böhringer, H., & Lemson, G. 2012, MNRAS, 420, 3545

.. [Bif13] Biffi, V., Dolag, K., Böhringer, H. 2013, MNRAS, 428, 1395 

.. [Tur11] Turk, M. J., Smith, B. D., Oishi, J. S., Skory, S., Skillman, S. W., Abel, T., & Norman, M. L. 2011, ApJS, 192, 9


